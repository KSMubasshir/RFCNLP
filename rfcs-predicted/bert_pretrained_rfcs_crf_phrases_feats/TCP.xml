<p><def_state id="1">listen</def_state>
<def_state id="2">syn-sent</def_state>
<def_state id="3">syn-received</def_state>
<def_state id="4">established</def_state>
<def_state id="5">fin-wait-1</def_state>
<def_state id="6">fin-wait-2</def_state>
<def_state id="7">close-wait</def_state>
<def_state id="8">closing</def_state>
<def_state id="9">last-ack</def_state>
<def_state id="10">time-wait</def_state>
<def_state id="11">closed</def_state>
<def_event id="7">ack</def_event>
<def_event id="8">psh</def_event>
<def_event id="9">rst</def_event>
<def_event id="10">syn</def_event>
<def_event id="11">fin</def_event>
<def_event id="1">open</def_event>
<def_event id="2">send</def_event>
<def_event id="3">receive</def_event>
<def_event id="4">close</def_event>
<def_event id="5">abort</def_event>
<def_event id="6">status</def_event>
<def_event id="12">segment arrives</def_event>
<def_event id="13">user timeout</def_event>
<def_event id="14">retransmission timeout</def_event>
<def_event id="15">time-wait timeout</def_event>

<control relevant="true">
	<trigger>in all states except <ref_state id="2">syn-sent</ref_state> , 	</trigger>
	<action type="receive">all <ref_event id="9" type="receive">reset</ref_event> ( <ref_event id="9" type="receive">rst</ref_event> ) segments are validated by checking their seq-fields . 		</action>

	<control relevant="true">
		<trigger>if its sequence number is in the window . 		</trigger>
	</control>
</control>

<control relevant="true">
	<action type="receive">in the syn-sent state ( a <ref_event id="9" type="receive">rst</ref_event> received in response to an initial <ref_event id="10" type="receive">syn</ref_event> ) , 		</action>

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="receive">ack field acknowledges the syn . </ref_event>		</trigger>
	</control>
</control>

<control relevant="true">
	<action type="receive">the receiver of a <ref_event id="9" type="receive">rst</ref_event> first validates it , 	</action>
	<transition>then changes state . 		</transition>

	<control relevant="true">
		<trigger>if the receiver was in the <ref_state id="1">listen</ref_state> state , 		</trigger>
		<action type="receive">it ignores it . 			</action>

		<control relevant="true">
			<trigger>if the receiver was in <ref_state id="3">syn-received</ref_state> state and had previously been in the <ref_state id="1">listen</ref_state> state , 			</trigger>
			<transition>then the receiver returns to the <ref_state id="1">listen</ref_state> state , 				</transition>

			<control relevant="true">
				<transition>otherwise the receiver aborts the connection and goes to the <ref_state id="11">closed</ref_state> state . 				</transition>
			</control>

			<control relevant="true">
				<trigger>if the receiver was in any other state , 				</trigger>
				<transition>it aborts the connection and advises the user and goes to the <ref_state id="11">closed</ref_state> state . 				</transition>
			</control>
		</control>
	</control>
</control>

<control relevant="true">
	<trigger>if the active/passive flag is set to passive , 	</trigger>
	<trigger>then this is a call to <ref_state id="1">listen</ref_state> for an incoming connection . 	</trigger>
</control>

<control relevant="true">
	<trigger><ref_event id="1" type="receive">open</ref_event> call  	</trigger> 

	<control relevant="true">
		<trigger><ref_state id="11">closed</ref_state> state ( i.e . , tcb does not exist )  		</trigger> 
		<action type="receive">create a new transmission control block ( tcb ) to hold connection state information . 		</action>
		<variable>fill in local socket identifier , 		</variable>foreign socket , 
		<variable>precedence , 		</variable>security/compartment , and user timeout information . 
		<action type="receive">note that some parts of the foreign socket may be unspecified in a passive <ref_event id="1" type="receive">open</ref_event> and are to be filled in by the parameters of the incoming <ref_event id="10" type="receive">syn</ref_event> segment . 			</action>

		<control relevant="true">
			<action type="receive">verify the security and precedence requested are allowed for this user , 			</action>
			<action type="receive">if not return `` error : precedence not allowed `` or `` error : security/compartment not allowed . 			</action>`` 
		</control>

		<control relevant="true">
			<trigger>if passive 			</trigger>
			<transition>enter the <ref_state id="1">listen</ref_state> state and return . 			</transition>
		</control>

		<control relevant="true">
			<trigger>if active and the foreign socket is unspecified , 			</trigger>
			<action type="receive">return `` error : foreign socket unspecified `` ; 			</action>
		</control>

		<control relevant="true">
			<trigger>if active and the foreign socket is specified , 			</trigger>
			<action type="issue">issue <arg> a <ref_event id="10" type="send">syn</ref_event> segment </arg> . 			</action>
			<action type="receive">an initial send sequence number ( iss ) is selected . 			</action>
			<action type="send"><arg> a <ref_event id="10" type="send">syn</ref_event> segment of the form &lt; seq=iss &gt; &lt; ctl=syn &gt; </arg> is sent . 			</action>
			<variable>set snd.una to iss , 			</variable>
			<transition>snd.nxt to iss+1 , enter <ref_state id="2">syn-sent</ref_state> state , 		</transition>
		</control>
		<action type="receive">and return . 		</action>  

		<control relevant="true">
			<trigger>if the caller does not have access to the local socket specified , 			</trigger>
			<variable>return `` error : connection illegal for this process `` . 			</variable>
		</control>

		<control relevant="true">
			<trigger>if there is no room to create a new connection , 			</trigger>
			<variable>return `` error : insufficient resources `` . 	</variable>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="1">listen</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if active and the foreign socket is specified , 			</trigger>
			<transition>then change the connection from passive to active , 			</transition>
			<action type="receive">select an iss . 			</action>
			<action type="send">send <arg> a <ref_event id="10" type="send">syn</ref_event> segment </arg> , 			</action>
			<variable>set snd.una to iss , 			</variable>
			<transition>snd.nxt to iss+1 . enter <arg_target><ref_state id="2">syn-sent</ref_state></arg_target> state . 			</transition>
			<action type="send"><arg> data associated with send </arg> may be sent with <ref_event id="10" type="send">syn</ref_event> segment or queued for transmission after entering established state . 			</action>the urgent bit 
			<action type="send">if requested in <arg> the command </arg> must be sent with the data segments sent as a result of this command . 				</action>

			<control relevant="true">
				<trigger>if there is no room to queue the request , 				</trigger>
				<error>respond with `` error : insufficient resources `` . 				</error>
			</control>

			<control relevant="true">
				<trigger>if foreign socket was not specified , 				</trigger>
				<action type="receive">then return `` error : foreign socket unspecified `` . 	</action>      
			</control>
		</control>
	</control>
	<trigger><ref_event id="1" type="receive">open</ref_event> call  		</trigger>

	<control relevant="true">
		<trigger><ref_state id="2">syn-sent</ref_state> state <ref_state id="3">syn-received</ref_state> state <ref_state id="4">established</ref_state> state <ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state <ref_state id="7">close-wait</ref_state> state <ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<error>return `` error : connection already exists `` . 		</error>
	</control>
</control>

<control relevant="true">
	<action type="send">send <arg> call </arg>  	</action> 

	<control relevant="true">
		<trigger><ref_state id="11">closed</ref_state> state ( i.e . , tcb does not exist )  		</trigger> 

		<control relevant="true">
			<trigger>if the user does not have access to such a connection , 			</trigger>
			<action type="receive">then return `` error : connection illegal for this process `` . 			</action>  
			<trigger>otherwise , 			</trigger>
			<variable>return `` error : connection does not exist `` . 	</variable>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="1">listen</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if the foreign socket is specified , 			</trigger>
			<transition>then change the connection from passive to active , 			</transition>
			<action type="receive">select an iss . 			</action>
			<action type="send">send <arg> a <ref_event id="10" type="send">syn</ref_event> segment </arg> , 			</action>
			<variable>set snd.una to iss , 			</variable>
			<transition>snd.nxt to iss+1 . enter <arg_target><ref_state id="2">syn-sent</ref_state></arg_target> state . 		</transition>
		</control>
		<action type="send"><arg> data associated with send </arg> may be sent with <ref_event id="10" type="send">syn</ref_event> segment or queued for transmission after entering established state . 		</action>the urgent bit 
		<action type="send">if requested in <arg> the command </arg> must be sent with the data segments sent as a result of this command . 			</action>

		<control relevant="true">
			<trigger>if there is no room to queue the request , 			</trigger>
			<error>respond with `` error : insufficient resources `` . 			</error>
		</control>

		<control relevant="true">
			<trigger>if foreign socket was not specified , 			</trigger>
			<action type="receive">then return `` error : foreign socket unspecified `` . 	</action>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="2">syn-sent</ref_state> state <ref_state id="3">syn-received</ref_state> state  		</trigger> 
		<transition>queue the data for transmission after entering <ref_state id="4">established</ref_state> state . 			</transition>

		<control relevant="true">
			<trigger>if no space to queue , 			</trigger>
			<variable>respond with `` error : insufficient resources `` . 	</variable>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="4">established</ref_state> state <ref_state id="7">close-wait</ref_state> state  		</trigger> 
		<action type="send">segmentize the buffer and send <arg> it </arg> with a piggybacked <ref_event id="7" type="send">acknowledgment</ref_event> ( <ref_event id="7" type="send">acknowledgment</ref_event> value = rcv.nxt ) . 			</action>

		<control relevant="true">
			<trigger>if there is insufficient space to remember this buffer , 			</trigger>
			<action type="receive">simply return `` error : insufficient resources `` . 		</action>  
		</control>

		<control relevant="true">
			<trigger>if the urgent flag is set , 			</trigger>
			<action type="receive">then snd.up &lt;- snd.nxt-1 and set the urgent pointer in the outgoing segments . 	</action>      
		</control>
	</control>
	<action type="send">send <arg> call </arg>  		</action>

	<control relevant="true">
		<trigger><ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state <ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<transition>return `` error : connection <ref_state id="8">closing</ref_state> `` and do not service request . 		</transition>
	</control>
</control>

<control relevant="true">
	<action type="receive">receive <arg> call </arg>  	</action> 

	<control relevant="true">
		<trigger><ref_state id="11">closed</ref_state> state ( i.e . , tcb does not exist )  		</trigger> 

		<control relevant="true">
			<trigger>if the user does not have access to such a connection , 			</trigger>
			<variable>return `` error : connection illegal for this process `` . 			</variable>  
			<action type="receive">otherwise return `` error : connection does not exist `` . 	</action>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="1">listen</ref_state> state <ref_state id="2">syn-sent</ref_state> state <ref_state id="3">syn-received</ref_state> state  		</trigger> 
		<transition>queue for processing after entering <ref_state id="4">established</ref_state> state . 			</transition>

		<control relevant="true">
			<trigger>if there is no room to queue this request , 			</trigger>
			<variable>respond with `` error : insufficient resources `` . 	</variable>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="4">established</ref_state> state <ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if insufficient incoming segments are queued to satisfy the request , 			</trigger>
			<action type="receive">queue the request . 			</action>
		</control>

		<control relevant="true">
			<trigger>if there is no queue space to remember the receive , 			</trigger>
			<variable>respond with `` error : insufficient resources `` . 		</variable>  
		</control>

		<control relevant="true">
			<action type="receive">reassemble queued incoming segments into receive buffer and return to user . 			</action>mark `` push seen `` ( push ) 
			<trigger>if this is the case . 		</trigger>  
		</control>

		<control relevant="true">
			<trigger>if rcv.up is in advance of the data currently being passed to the user notify the user of the presence of urgent data . 		</trigger>  
		</control>
		<action type="receive">when the tcp takes responsibility for delivering data to the user that fact must be communicated to the sender via an <ref_event id="7" type="receive">acknowledgment</ref_event> . 		</action>
		<action type="receive">the formation of such an <ref_event id="7" type="receive">acknowledgment</ref_event> is described below in the discussion of processing an incoming segment . 	</action>      
	</control>
	<action type="receive">receive <arg> call </arg>  		</action>

	<control relevant="true">
		<trigger><ref_state id="7">close-wait</ref_state> state  		</trigger> 
		<trigger>since the remote side has already sent <ref_event id="11" type="send">fin</ref_event> , 		</trigger>
		<action type="receive">receives must be satisfied by text already on hand , 		</action>
		<action type="receive">but not yet delivered to the user . 			</action>

		<control relevant="true">
			<trigger>if no text is awaiting delivery , 			</trigger>
			<action type="receive">the receive will get a `` error : connection closing `` response . 			</action>
			<trigger>otherwise , 			</trigger>
			<action type="receive">any remaining text can be used to satisfy the receive . 	</action>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<transition>return `` error : connection <ref_state id="8">closing</ref_state> `` . 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger><ref_event id="4" type="receive">close</ref_event> call  	</trigger> 

	<control relevant="true">
		<trigger><ref_state id="11">closed</ref_state> state ( i.e . , tcb does not exist )  		</trigger> 

		<control relevant="true">
			<trigger>if the user does not have access to such a connection , 			</trigger>
			<variable>return `` error : connection illegal for this process `` . 			</variable>  
			<trigger>otherwise , 			</trigger>
			<variable>return `` error : connection does not exist `` . 	</variable>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="1">listen</ref_state> state  		</trigger> 
		<transition>any outstanding receives are returned with `` error : <ref_state id="8">closing</ref_state> `` responses . 		</transition>
		<action type="receive">delete tcb , 		</action>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 	</action>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="2">syn-sent</ref_state> state  		</trigger> 
		<transition>delete the tcb and return `` error : <ref_state id="8">closing</ref_state> `` responses to any queued sends , 		</transition>
		<trigger>or receives . 	</trigger>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="3">syn-received</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if no sends have been issued and there is no pending data to send , 			</trigger>
			<action type="send">then form <arg> a <ref_event id="11" type="send">fin</ref_event> segment </arg> and send it , 			</action>
			<transition>and enter <ref_state id="5">fin-wait-1</ref_state> state ; otherwise queue for processing after entering <ref_state id="4">established</ref_state> state . 	</transition>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="4">established</ref_state> state  		</trigger> 
		<action type="receive">queue this until all preceding sends have been segmentized , 		</action>
		<action type="send">then form <arg> a <ref_event id="11" type="send">fin</ref_event> segment </arg> and send it . 		</action>in any case , 
		<transition>enter <ref_state id="5">fin-wait-1</ref_state> state . 	</transition>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state  		</trigger> strictly speaking , 
		<action type="receive">this is an error and should receive <arg> a `` error : connection closing `` response </arg> . 		</action>
		<action type="receive">an `` ok `` response would be acceptable , 		</action>too , 
		<trigger>as long as a second <ref_event id="11" type="receive">fin</ref_event> is not emitted ( the first <ref_event id="11" type="receive">fin</ref_event> may be retransmitted though ) . 	</trigger>      
	</control>
	<trigger><ref_event id="4" type="receive">close</ref_event> call  		</trigger>

	<control relevant="true">
		<trigger><ref_state id="7">close-wait</ref_state> state  		</trigger> 
		<trigger>queue this request until all preceding sends have been segmentized ; 		</trigger>
		<action type="send">then send <arg> a <ref_event id="11" type="send">fin</ref_event> segment </arg> , 		</action>
		<transition>enter <ref_state id="8">closing</ref_state> state . 	</transition>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<trigger>respond with `` error : connection <ref_state id="8">closing</ref_state> `` . 		</trigger>
	</control>
</control>

<control relevant="true">
	<trigger><ref_event id="5" type="receive">abort</ref_event> call  	</trigger> 

	<control relevant="true">
		<trigger><ref_state id="11">closed</ref_state> state ( i.e . , tcb does not exist )  		</trigger> 

		<control relevant="true">
			<trigger>if the user should not have access to such a connection , 			</trigger>
			<variable>return `` error : connection illegal for this process `` . 			</variable>  
			<action type="receive">otherwise return `` error : connection does not exist `` . 	</action>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="1">listen</ref_state> state  		</trigger> 
		<action type="receive">any outstanding receives should be returned with `` error : connection <ref_event id="9" type="receive">reset</ref_event> `` responses . 		</action>
		<action type="receive">delete tcb , 		</action>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 	</action>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="2">syn-sent</ref_state> state  		</trigger> 
		<action type="receive">all queued sends and receives should be given `` connection <ref_event id="9" type="receive">reset</ref_event> `` notification , 		</action>
		<action type="receive">delete the tcb , 		</action>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 	</action>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="3">syn-received</ref_state> state <ref_state id="4">established</ref_state> state <ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state <ref_state id="7">close-wait</ref_state> state  		</trigger> 
		<action type="send">send <arg> a <ref_event id="9" type="send">reset</ref_event> segment </arg> :  		</action> 
		<variable>&lt; seq=snd.nxt &gt; &lt; ctl=rst &gt;  		</variable> 
		<action type="receive">all queued sends and receives should be given `` connection <ref_event id="9" type="receive">reset</ref_event> `` notification ; 		</action>
		<action type="issue">all segments queued for transmission ( except for <arg> the <ref_event id="9" type="send">rst</ref_event> </arg> formed above ) or retransmission should be flushed , 		</action>
		<action type="receive">delete the tcb , 		</action>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 	</action>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<trigger>respond with `` ok `` and delete the tcb , 		</trigger>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger>if the state is <ref_state id="11">closed</ref_state> ( i.e . , tcb does not exist ) 	</trigger>then   
	<action type="receive">all data in the incoming segment is discarded . 		</action>

	<control relevant="true">
		<trigger>an incoming segment containing a <ref_event id="9" type="receive">rst</ref_event> is discarded . 		</trigger>
	</control>

	<control relevant="true">
		<trigger>an incoming segment not containing a <ref_event id="9" type="send">rst</ref_event> causes a <ref_event id="9" type="send">rst</ref_event> to be sent in response . 	</trigger>
	</control>
	<action type="send">the <ref_event id="7" type="send">acknowledgment</ref_event> and sequence field values are selected to make the <ref_event id="9" type="send">reset</ref_event> sequence acceptable to the tcp that sent <arg> the offending segment </arg> . 	</action>  

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="receive">ack</ref_event> bit is off , 		</trigger>
		<action type="receive">sequence number zero is used , 		</action>  
		<variable>&lt; seq=0 &gt; &lt; ack=seg.seq+seg.len &gt; &lt; ctl=rst , 		</variable><ref_event id="7" type="None">ack</ref_event> &gt;   
		<trigger>if the <ref_event id="7" type="receive">ack</ref_event> bit is on , 		</trigger>  
		<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  		</trigger> 
		<transition>return . 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger>if the state is <ref_state id="1">listen</ref_state> 	</trigger>then   
	<trigger>first check for an <ref_event id="9" type="receive">rst</ref_event>  	</trigger> 
	<action type="receive">an incoming <ref_event id="9" type="receive">rst</ref_event> should be ignored . 	</action>
	<transition>return . 	</transition>  
	<trigger>second check for an <ref_event id="7" type="receive">ack</ref_event>  	</trigger> 
	<action type="receive">any <ref_event id="7" type="receive">acknowledgment</ref_event> is bad 	</action>
	<trigger>if it arrives on a connection still in the <ref_state id="1">listen</ref_state> state . 	</trigger>
	<action type="issue"><arg> an acceptable <ref_event id="9" type="send">reset</ref_event> segment </arg> should be formed for any arriving ack-bearing segment . 	</action>
	<action type="issue"><arg> the <ref_event id="9" type="send">rst</ref_event> </arg> should be formatted as follows :  	</action> 
	<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  	</trigger> 
	<transition>return . 	</transition>  
	<trigger>third check for a <ref_event id="10" type="receive">syn</ref_event>  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_event id="10" type="receive">syn</ref_event> bit is set , 		</trigger>
		<trigger>check the security . 			</trigger>

		<control relevant="true">
			<trigger>if the security/compartment on the incoming segment does not exactly match the security/compartment in the tcb 			</trigger>
			<action type="send">then send <arg> a <ref_event id="9" type="send">reset</ref_event> and return </arg> . 			</action>  
		</control>
		<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  		</trigger>      
		<trigger>segment arrives  		</trigger> 

		<control relevant="true">
			<trigger>if the seg.prc is greater than the tcb.prc 			</trigger>then 
			<trigger>if allowed by the user and the system set tcb.prc &lt; -seg.prc , 			</trigger>
			<action type="send">if not allowed send <arg> a <ref_event id="9" type="send">reset</ref_event> and return </arg> . 			</action>  
		</control>
		<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  		</trigger> 

		<control relevant="true">
			<trigger>if the seg.prc is less than the tcb.prc 			</trigger>then continue .   
		</control>
		<variable>set rcv.nxt to seg.seq+1 , 		</variable>
		<variable>irs is set to seg.seq and any other control or text should be queued for processing later . 		</variable>
		<action type="send">iss should be selected and <arg> a <ref_event id="10" type="send">syn</ref_event> segment </arg> sent of the form :  		</action> 
		<variable>&lt; seq=iss &gt; &lt; ack=rcv.nxt &gt; &lt; ctl=syn , 		</variable><ref_event id="7" type="None">ack</ref_event> &gt;   
		<variable>snd.nxt is set to iss+1 and snd.una to iss . 		</variable>
		<transition>the connection state should be changed to <arg_target><ref_state id="3">syn-received</ref_state></arg_target> . 		</transition>
		<action type="receive">note that any other incoming control or data ( combined with <ref_event id="10" type="receive">syn</ref_event> ) will be processed in the syn-received state , 		</action>
		<action type="receive">but processing of <ref_event id="10" type="receive">syn</ref_event> and <ref_event id="7" type="receive">ack</ref_event> should not be repeated . 			</action>

		<control relevant="true">
			<trigger>if the <ref_state id="1">listen</ref_state> was not fully specified ( i.e . , the foreign socket was not fully specified ) , 			</trigger>
			<action type="receive">then the unspecified fields should be filled in now . 	</action>  fourth other text or control   
		</control>
	</control>
	<action type="receive">any other control or text-bearing segment ( not containing <ref_event id="10" type="receive">syn</ref_event> ) must have an <ref_event id="7" type="receive">ack</ref_event> and thus would be discarded by the <ref_event id="7" type="receive">ack</ref_event> processing . 	</action>
	<trigger>an incoming <ref_event id="9" type="receive">rst</ref_event> segment could not be valid , 	</trigger>since it could not have been sent in response to anything sent by this incarnation of the connection . so you are unlikely to get here , but 
	<trigger>if you do , 	</trigger>
	<action type="receive">drop the segment , 	</action>
	<action type="receive">and return . 	</action>
</control>

<control relevant="true">
	<trigger>if the state is <ref_state id="2">syn-sent</ref_state> 	</trigger>then   
	<action type="receive">first check the <ref_event id="7" type="receive">ack</ref_event> bit  	</action> 

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="receive">ack</ref_event> bit is set  		</trigger> 
		<trigger>if seg.ack = &lt; iss , 		</trigger>
		<trigger>or seg.ack &gt; snd.nxt , 		</trigger>
	</control>

	<control relevant="true">
		<action type="send">send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg> ( unless the <ref_event id="9" type="send">rst</ref_event> bit is set , if so drop the segment and return )  		</action> 
		<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  		</trigger> 
		<action type="receive">and discard the segment . 		</action>
		<transition>return . 	</transition>  
	</control>
	<trigger>if snd.una = &lt; seg.ack = &lt; snd.nxt 	</trigger>
	<action type="receive">then the <ref_event id="7" type="receive">ack</ref_event> is acceptable . 	</action>  
	<action type="receive">second check the <ref_event id="9" type="receive">rst</ref_event> bit  	</action>     
	<trigger>segment arrives  		</trigger>

	<control relevant="true">
		<trigger>if the <ref_event id="9" type="receive">rst</ref_event> bit is set  		</trigger> 
		<trigger>if the <ref_event id="7" type="receive">ack</ref_event> was acceptable 		</trigger>
		<action type="receive">then signal the user `` error : connection <ref_event id="9" type="receive">reset</ref_event> `` , 		</action>
		<action type="receive">drop the segment , 		</action>
		<transition>enter <ref_state id="11">closed</ref_state> state , 		</transition>
		<trigger>delete tcb , 		</trigger>
		<action type="receive">and return . 		</action>
		<trigger>otherwise ( no <ref_event id="7" type="receive">ack</ref_event> ) drop the segment and return . 	</trigger>  
	</control>
	<action type="receive">third check the security and precedence  	</action> 

	<control relevant="true">
		<trigger>if the security/compartment in the segment does not exactly match the security/compartment in the tcb , 		</trigger>
		<action type="send">send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg>  		</action> 
		<trigger>if there is an <ref_event id="7" type="receive">ack</ref_event>  		</trigger> 
		<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  		</trigger> 
		<trigger>otherwise  		</trigger> 
		<variable>&lt; seq=0 &gt; &lt; ack=seg.seq+seg.len &gt; &lt; ctl=rst , 	</variable><ref_event id="7" type="None">ack</ref_event> &gt;   
	</control>

	<control relevant="true">
		<trigger>if there is an <ref_event id="7" type="receive">ack</ref_event>  		</trigger> the precedence in the segment must match the precedence in the tcb , 
		<trigger>if not , 		</trigger>
		<action type="send">send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg>  		</action> 
	</control>
	<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  	</trigger> 

	<control relevant="true">
		<trigger>if there is no <ref_event id="7" type="receive">ack</ref_event>  		</trigger> 
		<trigger>if the precedence in the segment is higher than the precedence in the tcb 		</trigger>then 
		<trigger>if allowed by the user and the system raise the precedence in the tcb to that in the segment , 		</trigger>
		<trigger>if not allowed to raise the prec 		</trigger>
		<action type="send">then send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg> . 		</action>  
		<variable>&lt; seq=0 &gt; &lt; ack=seg.seq+seg.len &gt; &lt; ctl=rst , 	</variable><ref_event id="7" type="None">ack</ref_event> &gt;   
	</control>

	<control relevant="true">
		<trigger>if the precedence in the segment is lower than the precedence in the tcb continue . 	</trigger>  
	</control>

	<control relevant="true">
		<trigger>if a <ref_event id="9" type="send">reset</ref_event> was sent , 		</trigger>
		<action type="receive">discard the segment and return . 	</action>  
	</control>
	<action type="receive">fourth check the <ref_event id="10" type="receive">syn</ref_event> bit  	</action> this step should be reached only 
	<trigger>if the <ref_event id="7" type="receive">ack</ref_event> is ok , 	</trigger>
	<trigger>or there is no <ref_event id="7" type="receive">ack</ref_event> , 	</trigger>
	<action type="receive">and it the segment did not contain a <ref_event id="9" type="receive">rst</ref_event> . 	</action>  

	<control relevant="true">
		<trigger>if the <ref_event id="10" type="receive">syn</ref_event> bit is on and the security/compartment and precedence  		</trigger>      
		<trigger>segment arrives  		</trigger> 
		<action type="receive">are acceptable 		</action>then , 
		<variable>rcv.nxt is set to seg.seq+1 , 		</variable>
		<variable>irs is set to seg.seq . 		</variable>
		<variable>snd.una should be advanced to equal seg.ack ( if there is an <ref_event id="7" type="None">ack</ref_event> ) , 		</variable>
		<action type="receive">and any segments on the retransmission queue which are thereby acknowledged should be removed . 	</action>  
	</control>

	<control relevant="true">
		<trigger>if snd.una &gt; iss ( our <ref_event id="7" type="receive">syn has been acked </ref_event>) , 		</trigger>
		<transition>change the connection state to <arg_target><ref_state id="4">established</ref_state></arg_target> , 		</transition>
		<action type="issue">form <arg> an <ref_event id="7" type="send">ack</ref_event> segment </arg>  		</action> 
		<variable>&lt; seq=snd.nxt &gt; &lt; ack=rcv.nxt &gt; &lt; ctl=ack &gt;  		</variable> 
		<action type="send">and send <arg> it </arg> . 		</action>
		<trigger>data or controls which were queued for transmission may be included . 		</trigger>
	</control>

	<control relevant="true">
		<trigger>if there are other controls or text in the segment 		</trigger>
		<transition>then continue processing at the sixth step below where the urg bit is checked , 		</transition>
		<action type="receive">otherwise return . 		</action>  
		<transition>otherwise enter <ref_state id="3">syn-received</ref_state> , 		</transition>
		<action type="issue">form <arg> a <ref_event id="10" type="send">syn</ref_event> </arg> , 		</action>
		<action type="receive"><ref_event id="7" type="receive">ack</ref_event> segment  		</action> 
		<variable>&lt; seq=iss &gt; &lt; ack=rcv.nxt &gt; &lt; ctl=syn , 		</variable><ref_event id="7" type="None">ack</ref_event> &gt;   
		<action type="send">and send <arg> it </arg> . 		</action>
	</control>

	<control relevant="true">
		<trigger>if there are other controls or text in the segment , 		</trigger>
		<trigger>queue them for processing after the <ref_state id="4">established</ref_state> state has been reached , 		</trigger>
		<action type="receive">return . 		</action>  
		<trigger>fifth , 			</trigger>

		<control relevant="true">
			<trigger>if neither of the <ref_event id="10" type="receive">syn</ref_event> or <ref_event id="9" type="receive">rst</ref_event> bits is set 			</trigger>
			<action type="receive">then drop the segment and return . 			</action>
		</control>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="3">syn-received</ref_state> state <ref_state id="4">established</ref_state> state <ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state <ref_state id="7">close-wait</ref_state> state <ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  	</trigger> 
	<action type="receive">segments are processed in sequence . 	</action>
	<trigger>initial tests on arrival are used to discard old duplicates , 	</trigger>
	<trigger>but further processing is done in seg.seq order . 	</trigger>
	<trigger>if a segment ` s contents straddle the boundary between old and new , 	</trigger>
	<action type="receive">only the new parts should be processed . 	</action>  
	<trigger>there are four cases for the acceptability test for an incoming segment :  	</trigger> 
	<action type="receive">segment receive <arg> test length window -- -- -- - -- -- -- - -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- </arg> -- -  	</action> 
	<variable>0 0 seg.seq = rcv.nxt  	</variable> 
	<variable>0 &gt; 0 rcv.nxt = &lt; seg.seq &lt; rcv.nxt+rcv.wnd  	</variable> 
	<variable>&gt; 0 0 not acceptable  	</variable> 
	<variable>&gt; 0 &gt; 0 rcv.nxt = &lt; seg.seq &lt; rcv.nxt+rcv.wnd  	</variable>
	<trigger>or rcv.nxt = &lt; seg.seq+seg.len-1 &lt; rcv.nxt+rcv.wnd  	</trigger> 

	<control relevant="true">
		<trigger>if the rcv.wnd is zero , 		</trigger>
		<action type="receive">no segments will be acceptable , 		</action>
		<action type="receive">but special allowance should be made to accept valid acks , 		</action>
		<action type="receive">urgs and rsts . 	</action>  
	</control>

	<control relevant="true">
		<trigger>if an incoming segment is not acceptable , 		</trigger>
		<action type="send"><arg> an <ref_event id="7" type="send">acknowledgment</ref_event> </arg> should be sent in reply ( unless the <ref_event id="9" type="send">rst</ref_event> bit is set , if so drop the segment and return ) :  		</action> 
	</control>
	<variable>&lt; seq=snd.nxt &gt; &lt; ack=rcv.nxt &gt; &lt; ctl=ack &gt;  	</variable> 

	<control relevant="true">
		<action type="send">after sending <arg> the <ref_event id="7" type="send">acknowledgment</ref_event> </arg> , 		</action>
		<action type="receive">drop the unacceptable segment and return . 	</action>       
	</control>
	<trigger>segment arrives  	</trigger> in the following it is assumed that the segment is the idealized segment that begins at rcv.nxt and does not exceed the window . 
	<action type="receive">one could tailor actual segments to fit this assumption by trimming off any portions that lie outside the window ( including <ref_event id="10" type="receive">syn</ref_event> and <ref_event id="11" type="receive">fin</ref_event> ) , 	</action>and only processing further 
	<trigger>if the segment 	</trigger>
	<transition>then begins at rcv.nxt . 	</transition>
	<trigger>segments with higher begining sequence numbers may be held for later processing . 	</trigger>
</control>

<control relevant="true">
	<trigger><ref_state id="3">syn-received</ref_state> state  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_event id="9" type="receive">rst</ref_event> bit is set  		</trigger> 

		<control relevant="true">
			<trigger>if this connection was initiated with a passive <ref_event id="1" type="receive">open</ref_event> ( i.e . , came from the <ref_state id="1">listen</ref_state> state ) , 			</trigger>
			<transition>then return this connection to <ref_state id="1">listen</ref_state> state and return . 			</transition>
			<action type="receive">the user need not be informed . 			</action>
		</control>

		<control relevant="true">
			<trigger>if this connection was initiated with an active <ref_event id="1" type="receive">open</ref_event> ( i.e . , came from <ref_state id="2">syn-sent</ref_state> state ) 			</trigger>
			<action type="receive">then the connection was refused , 			</action>
			<action type="receive">signal the user `` connection refused `` . 		</action>in either case , 
		</control>
		<action type="receive">all segments on the retransmission queue should be removed . 		</action>
		<trigger>and in the active <ref_event id="1" type="receive">open</ref_event> case , 		</trigger>
		<transition>enter the <ref_state id="11">closed</ref_state> state and delete the tcb , 		</transition>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="4">established</ref_state> <ref_state id="5">fin-wait-1</ref_state> <ref_state id="6">fin-wait-2</ref_state> <ref_state id="7">close-wait</ref_state>  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_event id="9" type="receive">rst</ref_event> bit is set 		</trigger>then , 
		<action type="send"><arg> any </arg> outstanding receives and send should receive `` <ref_event id="9" type="send">reset</ref_event> `` responses . 		</action>
		<action type="receive">all segment queues should be flushed . 		</action>
		<action type="receive">users should also receive <arg> an unsolicited general `` connection <ref_event id="9" type="receive">reset</ref_event> `` signal </arg> . 		</action>
		<transition>enter the <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">delete the tcb , 		</action>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state>  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_event id="9" type="receive">rst</ref_event> bit is set 		</trigger>then , 
		<transition>enter the <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">delete the tcb , 		</action>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="3">syn-received</ref_state>  	</trigger> 

	<control relevant="true">
		<trigger>if the security/compartment and precedence in the segment do not exactly match the security/compartment and precedence in the tcb 		</trigger>
		<action type="send">then send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg> , 		</action>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="4">established</ref_state> state  	</trigger> 

	<control relevant="true">
		<trigger>if the security/compartment and precedence in the segment do not exactly match the security/compartment and precedence in the tcb 		</trigger>
		<action type="send">then send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg> , 		</action>
		<action type="send"><arg> any </arg> outstanding receives and send should receive `` <ref_event id="9" type="send">reset</ref_event> `` responses . 		</action>
		<action type="receive">all segment queues should be flushed . 		</action>
		<action type="receive">users should also receive <arg> an unsolicited general `` connection <ref_event id="9" type="receive">reset</ref_event> `` signal </arg> . 		</action>
		<transition>enter the <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">delete the tcb , 		</action>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="3">syn-received</ref_state> <ref_state id="4">established</ref_state> state fin-wait state-1 fin-wait state-2 <ref_state id="7">close-wait</ref_state> state <ref_state id="8">closing</ref_state> state <ref_state id="9">last-ack</ref_state> state <ref_state id="10">time-wait</ref_state> state  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_event id="10" type="receive">syn</ref_event> is in the window it is an error , 		</trigger>
		<action type="send">send <arg> a <ref_event id="9" type="send">reset</ref_event> </arg> , 		</action>
		<action type="send"><arg> any </arg> outstanding receives and send should receive `` <ref_event id="9" type="send">reset</ref_event> `` responses , 		</action>
		<action type="receive">all segment queues should be flushed , 		</action>
		<action type="receive">the user should also receive <arg> an unsolicited general `` connection <ref_event id="9" type="receive">reset</ref_event> `` signal </arg> , 		</action>
		<transition>enter the <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">delete the tcb , 		</action>
		<action type="receive">and return . 	</action>  
	</control>
	<trigger>if the <ref_event id="10" type="send">syn</ref_event> is not in the window this step would not be reached and an <ref_event id="7" type="send">ack</ref_event> would have been sent in the first step ( sequence number check ) . 	</trigger>
</control>

<control relevant="true">
	<trigger>if the <ref_event id="7" type="receive">ack</ref_event> bit is off drop the segment and return 	</trigger>
</control>

<control relevant="true">
	<trigger>if the <ref_event id="7" type="receive">ack</ref_event> bit is on  	</trigger> 

	<control relevant="true">
		<trigger><ref_state id="3">syn-received</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if snd.una = &lt; seg.ack = &lt; snd.nxt 			</trigger>
			<transition>then enter <ref_state id="4">established</ref_state> state and continue processing . 			</transition>  

			<control relevant="true">
				<trigger>if the segment <ref_event id="7" type="receive">acknowledgment</ref_event> is not acceptable , 				</trigger>
				<action type="issue">form <arg> a <ref_event id="9" type="send">reset</ref_event> segment </arg> , 				</action>  
				<trigger>&lt; seq=seg.ack &gt; &lt; ctl=rst &gt;  				</trigger> 
				<action type="send">and send <arg> it </arg> . 				</action>
			</control>
		</control>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="4">established</ref_state> state  	</trigger> 

	<control relevant="true">
		<trigger>if snd.una &lt; seg.ack = &lt; snd.nxt 		</trigger>then , 
		<variable>set snd.una &lt;- seg.ack . 		</variable>
		<action type="receive">any segments on the retransmission queue which are thereby entirely acknowledged are removed . 		</action>
		<action type="receive">users should receive <arg> positive acknowledgments for buffers which have been sent and fully acknowledged </arg> ( i.e . , send buffer should be returned with `` ok `` response ) . 		</action>
	</control>

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="receive">ack</ref_event> is a duplicate ( seg.ack &lt; snd.una ) , 		</trigger>
		<action type="receive">it can be ignored . 		</action>
	</control>

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="send">ack</ref_event> acks something not yet sent ( seg.ack &gt; snd.nxt ) 		</trigger>
		<action type="send">then send <arg> an <ref_event id="7" type="send">ack</ref_event> </arg> , 		</action>
		<action type="receive">drop the segment , 		</action>
		<action type="receive">and return . 	</action>  
	</control>

	<control relevant="true">
		<trigger>if snd.una &lt; seg.ack = &lt; snd.nxt , 		</trigger>
		<action type="receive">the send window should be updated . 		</action>
	</control>

	<control relevant="true">
		<trigger>if ( snd.wl1 &lt; seg.seq or ( snd.wl1 = seg.seq and snd.wl2 = &lt; seg.ack ) ) , 		</trigger>
		<variable>set snd.wnd &lt;- seg.wnd , 		</variable>
		<variable>set snd.wl1 &lt;- seg.seq , 		</variable>
		<variable>and set snd.wl2 &lt;- seg.ack . 	</variable>  
	</control>
	<variable>note that snd.wnd is an offset from snd.una , 	</variable>
	<action type="receive">that snd.wl1 records the sequence number of the last segment used to update snd.wnd , 	</action>
	<action type="receive">and that snd.wl2 records the <ref_event id="7" type="receive">acknowledgment</ref_event> number of the last segment used to update snd.wnd . 	</action>the check here prevents using old segments to update the window . 
</control>

<control relevant="true">
	<trigger><ref_state id="5">fin-wait-1</ref_state> state  	</trigger> in addition to the processing for the established state , 

	<control relevant="true">
		<trigger>if our <ref_event id="7" type="receive">fin is now acknowledged </ref_event>		</trigger>
		<transition>then enter <ref_state id="6">fin-wait-2</ref_state> and continue processing in that state . 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="8">closing</ref_state> state  	</trigger> in addition to the processing for the established state , 

	<control relevant="true">
		<trigger>if the <ref_event id="7" type="receive">ack acknowledges our fin </ref_event>		</trigger>
		<transition>then enter the <ref_state id="10">time-wait</ref_state> state , 		</transition>
		<action type="receive">otherwise ignore the segment . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="9">last-ack</ref_state> state  	</trigger> 
	<action type="receive">the only thing that can arrive in this state is an <ref_event id="7" type="receive">acknowledgment of our fin . </ref_event>		</action>

	<control relevant="true">
		<trigger>if our <ref_event id="7" type="receive">fin is now acknowledged </ref_event>, 		</trigger>
		<action type="receive">delete the tcb , 		</action>
		<transition>enter the <ref_state id="11">closed</ref_state> state , 		</transition>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="10">time-wait</ref_state> state  	</trigger> 
	<action type="receive">the only thing that can arrive in this state is a retransmission of the remote <ref_event id="11" type="receive">fin</ref_event> . 	</action>
	<action type="receive">acknowledge it , 	</action>
	<timer>and restart the 2 msl timeout . 	</timer>
</control>

<control relevant="true">
	<trigger><ref_state id="4">established</ref_state> state <ref_state id="5">fin-wait-1</ref_state> state <ref_state id="6">fin-wait-2</ref_state> state  	</trigger> 

	<control relevant="true">
		<trigger>if the urg bit is set , 		</trigger>
		<trigger>rcv.up &lt;- max ( rcv.up , seg.up ) , 	</trigger>
	</control>
	<action type="receive">and signal the user that the remote side has urgent data 	</action>
	<trigger>if the urgent pointer ( rcv.up ) is in advance of the data consumed . 	</trigger>
	<trigger>if the user has already been signaled ( or is still in the `` urgent mode `` ) for this continuous sequence of urgent data , 	</trigger>do not signal the user again . 
</control>

<control relevant="true">
	<trigger>if the <ref_event id="11" type="receive">fin</ref_event> bit is set , 	</trigger>
	<transition>signal the user `` connection <ref_state id="8">closing</ref_state> `` and return any pending receives with same message , 	</transition>
	<action type="receive">advance rcv.nxt over the <ref_event id="11" type="receive">fin</ref_event> , 	</action>
	<action type="send">and send <arg> an <ref_event id="7" type="send">acknowledgment</ref_event> </arg> for the <ref_event id="11" type="send">fin</ref_event> . 	</action>
	<action type="receive">note that <ref_event id="11" type="receive">fin</ref_event> implies push for any segment text not yet delivered to the user . 	</action>  

	<control relevant="true">
		<trigger><ref_state id="3">syn-received</ref_state> state <ref_state id="4">established</ref_state> state  		</trigger> 
		<transition>enter the <ref_state id="7">close-wait</ref_state> state . 	</transition>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="5">fin-wait-1</ref_state> state  		</trigger> 

		<control relevant="true">
			<trigger>if our <ref_event id="7" type="receive">fin has been acked </ref_event>( perhaps in this segment ) , 			</trigger>
			<transition>then enter <ref_state id="10">time-wait</ref_state> , 			</transition>
			<trigger>start the <ref_state id="10">time-wait</ref_state> timer , 			</trigger>
			<timer>turn off the other timers ; 			</timer>
			<transition>otherwise enter the <ref_state id="8">closing</ref_state> state . 	</transition>  
		</control>
	</control>

	<control relevant="true">
		<trigger><ref_state id="6">fin-wait-2</ref_state> state  		</trigger> 
		<transition>enter the <ref_state id="10">time-wait</ref_state> state . 		</transition>
		<trigger>start the <ref_state id="10">time-wait</ref_state> timer , 		</trigger>
		<timer>turn off the other timers . 	</timer>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="7">close-wait</ref_state> state  		</trigger> 
		<transition>remain in the <ref_state id="7">close-wait</ref_state> state . 	</transition>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="8">closing</ref_state> state  		</trigger> 
		<transition>remain in the <ref_state id="8">closing</ref_state> state . 	</transition>  
	</control>

	<control relevant="true">
		<trigger><ref_state id="9">last-ack</ref_state> state  		</trigger> 
		<transition>remain in the <ref_state id="9">last-ack</ref_state> state . 	</transition>       
	</control>
	<trigger>segment arrives  	</trigger> 

	<control relevant="true">
		<trigger><ref_state id="10">time-wait</ref_state> state  		</trigger> 
		<transition>remain in the <ref_state id="10">time-wait</ref_state> state . 		</transition>
		<trigger>restart the 2 msl <ref_state id="10">time-wait</ref_state> timeout . 	</trigger>  
	</control>
	<action type="receive">and return . 	</action>
</control>

<control relevant="true">
	<trigger>user timeout  	</trigger> for any state 

	<control relevant="true">
		<trigger>if the user timeout expires , 		</trigger>
		<action type="receive">flush all queues , 		</action>
		<action type="receive">signal the user `` error : connection aborted due to user timeout `` in general and for any outstanding calls , 		</action>
		<action type="receive">delete the tcb , 		</action>
		<transition>enter the <ref_state id="11">closed</ref_state> state and return . 		</transition>
	</control>
</control>

<control relevant="true">
	<trigger>retransmission timeout  	</trigger> for any state 

	<control relevant="true">
		<trigger>if the retransmission timeout expires on a segment in the retransmission queue , 		</trigger>
		<action type="send">send <arg> the segment at the front of the retransmission queue </arg> again , 		</action>
		<timer>reinitialize the retransmission timer , 		</timer>
		<action type="receive">and return . 		</action>
	</control>
</control>

<control relevant="true">
	<trigger><ref_state id="10">time-wait</ref_state> timeout  	</trigger> 

	<control relevant="true">
		<trigger>if the <ref_state id="10">time-wait</ref_state> timeout expires on a connection delete the tcb , 		</trigger>
		<transition>enter the <ref_state id="11">closed</ref_state> state and return . 		</transition>
	</control>
</control>
</p>